# 1. mysql执行流程
## 1.1 Sql执行流程
1. 解析
   * 检查语法 确定库表
2. 预处理
   * 检查表列
   * 检查权限
   * 解析表达式,函数,子查询等
   * 确定表的连接顺序等 
3. 优化
   * 查询优化器自行决定高效的查询方式
   * 选择合适的索引,连接顺序等
   * 生成执行计划,描述如何高效执行sql
4. 执行
   * 根据执行计划执行sql
   * 排序,连接表等
   * 将查询结果放入结果集
5. 结果处理
   * 返回结果集
# 2. mysql四大特性
   * 原子性
     * 事务内的操作要么全部成功,要么全部失败,失败后数据保持原状态
   * 隔离性
     * 并发执行的各个事务之间不会互相影响
   * 持久性
     * 对数据的操作变更要存储到磁盘,系统崩溃时也能恢复
   * 一致性
     * 事务必须使数据库从一个状态变换到另一个一致性状态,事务的开始和结束之后,数据库的完整性没有破坏,数据满足业务约束
     * 一致性主要靠代码逻辑来保证
# 3: mysql存储引擎
1. innodb存储引擎
   * 基于B+树实现
   * 支持事务
   * 5.6版本以后支持全文索引
2. B+树
   * 只有叶子节点存储数据,非叶子存储索引,能够以更少的层数存储更多数据,减少磁盘I/O操作,视觉上更加矮胖
   * 叶子节点存储的数据以双向链表有序连接,查询效率更高,增删数据时只需操作叶子节点即可
   * 三层b+树
     * 根节点一个文件页 16kb 可 存储 (8+6)键值 1024个左右
     * 1170*1170*16=21902400(两千万左右) 第三层 预估每条数据记录1kb每个页存储16条数据
# 4: mysql索引分类
   * 主键索引 
     * B+树 非空 唯一
   * 唯一索引
     * 唯一,可非空,为空时一般不会触发全表扫描,优化器会执行优化策略
   * 普通索引
   * 全文索引
   * 复合索引
     * 在多个列上创建的索引。例如，可以在 (col1, col2, col3) 上创建一个组合索引。
     * 失效情况
     1. 最左前缀规则未遵守
     2. 使用范围查询或函数
     3. 查询条件中的数据类型与索引列的数据类型不匹配
     4. 某些情况下，使用 OR 可能会导致索引失效
     5. 查询条件跳过了组合索引中的某些列，那么索引可能不会被使用
     6. LIKE 进行模糊查询时，如果模式以通配符开始（如 %value），则索引通常不会被使用
     7. 索引列中的 NULL 值可能会影响索引的使用。在某些情况下，查询包含 NULL 值的列可能不会使用索引
   * 聚簇索引的特点：
     1. 数据物理顺序：聚簇索引决定了数据在磁盘上的物理存储顺序。因此，表中的数据行实际上是按照聚簇索引键的顺序存储的。

     2. 主键索引：在大多数数据库系统中，如果一个表定义了主键，那么主键自动成为聚簇索引。如果没有显式定义主键，数据库系统可能会选择一个唯一索引作为聚簇索引，或者允许用户指定一个列作为聚簇索引。

     3. 唯一性：聚簇索引通常要求索引键的值是唯一的。如果表中有重复的值，数据库系统可能不允许创建聚簇索引。

     4. 只有一个聚簇索引：每个表只能有一个聚簇索引，因为数据只能按照一种顺序物理存储。

     5. 性能优势：由于数据已经按照索引顺序物理存储，范围查询（例如，查询一个日期范围内的所有记录）可能会更快，因为数据是连续存储的。

     6. 插入和更新开销：由于数据行的物理位置由聚簇索引决定，因此插入和更新操作可能会导致更多的开销，因为可能需要移动数据行以维护索引顺序。

   * 非聚簇索引（Non-Clustered Index）
     1. 与聚簇索引相反，非聚簇索引并不改变数据行的物理存储顺序。非聚簇索引包含指向数据行的指针和索引键。多个非聚簇索引可以指向同一个数据表，因为非聚簇索引只包含指向数据的指针，而不是实际的数据行。
     2. 非聚簇索引的特点：
     物理存储独立：非聚簇索引不改变数据行的物理存储顺序。
     可以有多个：一个表可以有多个非聚簇索引，因为每个索引只包含指向数据行的指针，而不是实际的数据。
     插入和更新开销较小：由于非聚簇索引不改变数据的物理存储顺序，插入和更新操作通常比聚簇索引更快。
     性能考虑：非聚簇索引可能会增加查询时的 I/O 开销，因为除了读取索引页外，还需要读取数据页。
# 5. mysql-MVCC
   * 多个事务的执行顺序
     * 在MySQL中，多个事务的执行顺序不是按照它们的开始时间或提交时间来决定的。实际上，事务的执行顺序是由数据库管理系统（DBMS）的事务调度器来决定的，这取决于多种因素，包括事务的隔离级别、资源争用情况、数据库的配置以及查询优化器的决策等
   * 事务ID是如何生成的？
     * 